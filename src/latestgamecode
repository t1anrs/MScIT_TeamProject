
import java.util.Random;
import java.util.LinkedList;

/**
 * deck class set as linkedlist
 * @author RUNSHENG TIAN
 *
 */
public class Decklist {
	
	//Instance variables
	private int deckLastPointer;
	private String[] category;
	private LinkedList<Card> deck;
	
    /**
     * deck constructor
     * @param category: the card information
     */
	public Decklist(String[] category) {
		this.category = category;
		deck = new LinkedList<Card>();
		deckLastPointer = 0;
    	}
	
    /**
     * add a card to the first of the list
     * @param card: a card object
     */
	public void addCardToFirst(Card card) {
		deck.addFirst(card);
		this.deckLastPointer++;
	}
	
	/**
	 * add a card to the first of the list
	 * @param cardInfor: the card information
	 */
	public void addCardToFirst(String cardInfor) {
		Card newCard = new Card(cardInfor);	
		deck.addFirst(newCard);
		this.deckLastPointer++;
	}
	
	/**
	 * add a card to the last of the list
	 * @param card: card object
	 */
	public void addCardToLast(Card card) {
		deck.addLast(card);
		deckLastPointer++;
	}
	
	/**
	 * remove the first card from the list
	 */
	public void removeFirstCard() {
		if(deck.size()>0) {
		deck.removeFirst();
		deckLastPointer--;
		}
	}
	
	/**
	 * shuffles the Card based on Fisher-Yates shuffle algorithm
	 */
	public void shuffleDeck() {
		for(int i=0; i<deck.size()-2;i++) {
			Random ran = new Random();
			int r = i + ran.nextInt((deck.size()-i));
			
			Card swapcard = deck.get(i);
			deck.set(i,deck.get(r));
			deck.set(r, swapcard);
		}
	}
	
	/**
	 * get the first card and then remove it from the list 
	 * @return the first card
	 */
	public Card getTheTopCard() {
		Card topcard = deck.getFirst();
		removeFirstCard();
		return topcard;
	}
	
	/**
	 * @return the first card in the list
	 */
	public Card showTheTopCard() {
		return deck.getFirst();
	}
	
	/**
	 * check the player has card or not
	 * @return true if player has a card
	 */
	public Boolean hasCard() {
		if (deckLastPointer==0)
			return false;
		else
			return true;
	}
	
	
	public int getsize() {
		return deckLastPointer;
	}
	
	public int getCapacity() {
		return deck.size();
	}
	
	public String getCategoryName(int i) {
		return category[i - 1];
	}
	
	public String[] getCategory() {
		return category;
	}
	

	
	
}

import java.util.Random;

public class Game {
	
		
		// Instance variables
		private Decklist totalDeck, communalDeck;
		private Player[] player;
		private Player currentPlayer, roundWinner;
		private int numberOfOpponent;
		private int roundNum, drawNum;
		private int highestAttributeValue, comparedAttributeValue, drawAttributeValue;
		
		// set human player as the first position of Player 
		protected static final int HUMAN_PLAYER = 0;		
		// set 1 for win and 2 for draw 
		protected static final int STATE_ROUND_WON = 1;
		protected static final int STATE_ROUND_DRAW = 2;

		/**
		 * Constructor for a Game instance
		 * @param totallDeck: a Decklist including the cards 
		 * 		
		 */
		public Game(Decklist totalDeck) {
			this.totalDeck = totalDeck;
			communalDeck = new Decklist(totalDeck.getCategory());
		}
		
		/**
		 * @return a random integer to set as the first player 
		 * 
		 */
		private int randomFirstPlayer() {
			return new Random().nextInt(numberOfOpponent + 1);
		}
		
		/**
		 * shuffling the deck 
		 * dealing the top card to each player by turn until there are no cards left
		 */
		private void dealCardToPlayer() {
			
			totalDeck.shuffleDeck();
			
			for(int i = 0, j = 0; i < totalDeck.getCapacity(); i++) {
				player[j].getDeck().addCardToFirst(totalDeck.showTheTopCard());
				if(j < numberOfOpponent) {
					j++;
				}
				else {
					 j = 0;
				}
			
			}
				
		}
		
		/**
		 * Initiate a new game state and prepare to start the first round of a new game
		 * @param sumofopponents: the sum of opponents chosen by the human player when they start the game
		 * 
		 */
		public void startFirstRound(int numberOfOpponent) {
			this.numberOfOpponent = numberOfOpponent;
			
			player = new Player[numberOfOpponent + 1];
			for(int playerNumber = 0; playerNumber < numberOfOpponent + 1; playerNumber++) {
				player[playerNumber] = new Player(playerNumber, new Decklist(totalDeck.getCategory()));
			}
						
			dealCardToPlayer();  
			currentPlayer = player[randomFirstPlayer()];
			roundNum = 0;
			drawNum = 0;
		}
		
		
		
		/**
		 * current player choose a category and compare it with all other player who has cards
		 * set the player with the highest attribute value as the round winner or if draw keep the current player not change
		 * then returns the game state.
		 * @param chosenCategory: an integer which represents a category chosen by player
		 * @return 1 for win or 2 for draw
		 * 
		 */
		
		protected int eachRoundRun(int chosenCategory) {
						
			highestAttributeValue = currentPlayer.getDeck().showTheTopCard().getCategoryValue(chosenCategory);
			roundWinner = currentPlayer;			
			comparedAttributeValue = 0;
			drawAttributeValue = 0;
			roundNum++;
			
			// compare values iterate through each player who has a card
			for(int i = 0; i < numberOfOpponent + 1; i++) {
				
				if(player[i] != currentPlayer && player[i].getDeck().hasCard()) {
										
					comparedAttributeValue = player[i].getDeck().showTheTopCard().getCategoryValue(chosenCategory);
					
					if(comparedAttributeValue > highestAttributeValue) {
						highestAttributeValue = comparedAttributeValue;
						roundWinner = player[i];
					}
					else if(comparedAttributeValue == highestAttributeValue) {
						drawAttributeValue = highestAttributeValue;
					}
					else {
						// continue when compared value< highest value
						continue;
					}
					
				}
				
			}
						
			// return an integer representing round won or draw
		    if(highestAttributeValue == drawAttributeValue) {
		    	drawNum++;
		    	return STATE_ROUND_DRAW;
		    }
		    else {
		    	currentPlayer = roundWinner;
		    	currentPlayer.wonRound();
		    	drawNum = 0;
		    	return STATE_ROUND_WON;
		    }		    
		    
		}
		
		/**
		 * check if anyone has a card except the last round winner
		 * @return true if someone has been won
		 * 
		 */
		public boolean checkGameWon() {
			for(int i = 0; i < numberOfOpponent + 1; i++) {
				// At least two players will have cards to play in the next round
				if(player[i] != currentPlayer && player[i].getDeck().getCapacity() > 1) {				
					return false;		
			    }  
		    }
			// Only the currentPlayer will have cards in the next round
			return true;
		}
		
		/**
		 * the round has a winner
		 * then transfer the card in communal deck and all the cards played in this round to the round winner 
		 *  
		 */
		public void transferCardsToWinner() {
			
			// transfer cards from communal deck to last of the list
			if(communalDeck.hasCard()) {
				do {
					currentPlayer.getDeck().addCardToLast(communalDeck.getTheTopCard());
				} while(communalDeck.hasCard());
			}
			
			// give winner everyone's played-cards  to last of the list
			for(int i = 0; i < numberOfOpponent + 1; i++) {
				if(player[i].getDeck().hasCard()) {
					player[i].transferCardTo(currentPlayer.getDeck());
				}
			}
			
		}
		
		/**
		 * the round is draw 
		 * then transfer all top cards into the communal deck and check the player has a card or not before
		 * 
		 */
		public void transferCardsToCommunal() {
			for(int i = 0; i < numberOfOpponent; i++) {
				
				if(player[i].getDeck().hasCard()) {
					player[i].transferCardTo(communalDeck);
				}
			}
			
			if(!currentPlayer.getDeck().hasCard()) {
				for(int i = 0; i <= numberOfOpponent; i++) {
					if(player[i].getDeck().hasCard()) {
						currentPlayer = player[i];
					}
				}
			}
			
		}


		public Player getHumanPlayer() {
			return player[HUMAN_PLAYER];
		}
		
		// Accessors
		
		public Decklist getCommunalDeck(){
			return communalDeck;
		}
		
		public Player getCurrentPlayer() {
			return currentPlayer;
		}
		
		public int getRoundNum() {
			return roundNum;
		}

		public int getDrawNum() {
			return drawNum;
		}
		
		public Player getPlayer(int i){
			return player[i];
		}
		
		public int getNumOfPlayers() {
			return numberOfOpponent + 1;
		}

}

/** 
	 * player class
	 * choose the card category for computer players
	 * @author RUNSHENG TIAN
	 * 
	 */
public class Player {
	
	
	    //Instance variables
		private final int numOfCategories;
		private Decklist cardsInPlayerHand;
		private int playerNumber,categoryNum;
		private int roundsWon;

		public Player(int playerNumber, Decklist cardsInPlayerHand) {
			this.playerNumber = playerNumber;
			this.cardsInPlayerHand = cardsInPlayerHand;
			numOfCategories = cardsInPlayerHand.getCategory().length;
		}

		/**
		 * choose the highest attribute value of category for computer player
		 * @return index of the chosen category 
		 */
		public int chooseCategory() {  
			Card c = cardsInPlayerHand.showTheTopCard();
			
		    categoryNum = 1;
			for(int max = 0, i = 0; i < numOfCategories; i++) {
				int categoryValue = c.getCategoryValue(i + 1);			
				if(categoryValue > max) {
					max = categoryValue;
					categoryNum = i + 1;			
				}
			}
			return categoryNum;
		}
		
		/**
		 * transfers card from this player's deck to other players' decks or communal deck
		 */ 
		public void transferCardTo(Decklist deck) {   
			deck.addCardToLast(cardsInPlayerHand.getTheTopCard());
		}
        
		public Decklist getDeck(){   
			return cardsInPlayerHand;
		}
		
		public int getPlayerNumber() {
			return playerNumber;
		}
		
		/**
		 * Method increments rounds won.
		 */
		public void wonRound() {
					roundsWon++;
		}
		
		public int getRoundsWon() {
			return roundsWon;
		}

		

}

import java.util.Scanner;
/**
 * Running a game
 * @author RUNSHENG TIAN
 *
 */
public class StartOneGame {
	// Instance variables
	private Game newgame;
	private Decklist newdeck;
	private Scanner sc;
	private int numofchosencate;  //the number of the chosen category
	private int statenumber;
	
	/**
	 * Start a game and choose a category if the current player is human
	 */
	public StartOneGame() {
		newgame = new Game(new Decklist(newdeck.getCategory()));
		newgame.startFirstRound(4); // the number of opponents
		
		if(!newgame.checkGameWon()) {      // check is anyone won
				
			if(newgame.getDrawNum() != 0) {
				newgame.eachRoundRun(numofchosencate);
			}
			
			else {
				
				if(newgame.getCurrentPlayer()==newgame.getHumanPlayer()) {
			
			    // scanner the number of a category
			        sc = new Scanner(System.in);
			        numofchosencate = sc.nextInt();
		        }
		        else {
			        numofchosencate = newgame.getCurrentPlayer().chooseCategory();
		        }
			}
			
			
			    
			statenumber = newgame.eachRoundRun(numofchosencate);
			
			if(statenumber==1) {
				newgame.transferCardsToWinner();
				
			}
			else {
				newgame.transferCardsToCommunal();
			
		    }
		
	  }
		
	  // For assessment testing when someone won 
	  System.out.println(newgame.getCurrentPlayer() + " is the winner!");
	}

}

/**
 * Set the card information
 * @author RUNSHENG TIAN
 *
 */
public class Card {
	
	//Instance variables
	private String cardName, cardInfo;
	private final int sumOfAttributes=5;
	private int[] attribute= new int[sumOfAttributes];
	
	/**
	 * card constructor
	 * @param String  card information
	 * 
	 */
	public Card(String cardInformation) {	  //takes a string and breaks it into chunks
		this.cardInfo = cardInformation;
    	String [] categories = cardInformation.split("\\s+");
    	this.cardName = categories[0];					    	// title is the first word in the String
    	for (int i = 0; i < sumOfAttributes; i++){		// put category keywords into attribute array
    		attribute[i] = Integer.parseInt(categories[i+1]);
    	}
	}
	

	/**
	 * @return a String formatted ----- the card name and attributes value  	 * 
	 */
	public String toString(){	
		return cardInfo;  // return String used in constructor
	}
	
	
	/**
	 * get attribute value.
	 * @param integer represent category
	 * @return the attribute value of the category
	 */
	public int getCategoryValue(int categoryNum){
		return attribute[categoryNum-1];
	}
	
	
	/**
	 * @return card name
	 */
	public String getcardName(){
		return cardName;
		}
	
}



